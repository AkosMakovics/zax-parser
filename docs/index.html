<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>ZAX JSON PARSER</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>ZAX JSON PARSER</h1>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="images/ZaxJSONParser.png" alt="Zax JSON Parser" />
</span></p></div>
<div class="paragraph"><p>Zax is a very basic JSON parser implemented in C++11 with probably the simplest possible interface, providing a kind of a struct to JSON and JSON to struct conversion. I have tried it out only with 64 bit GCC compilers.
The library seems to work, but it has no tests, and its error handling was not even tried out. I made it public because I was searching for something similar in C++ previously without luck, and I hope it will be useful for someone. The implementation is missing some features, as I have implemented only the features I needed.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_architecture">Architecture</h2>
<div class="sectionbody">
<div class="paragraph"><p>Zax parser has a layered architecture. All the layers are accessible via an API.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<a href="#ZaxJsonFlatParser">ZaxJsonFlatParser</a>
</p>
</li>
<li>
<p>
<a href="#Converter_functions">Converter functions:</a>
</p>
<div class="ulist"><ul>
<li>
<p>
<a href="#zax_convert_from_json">zax_convert_from_json()</a>
</p>
</li>
<li>
<p>
<a href="#zax_convert_to_json">zax_convert_to_json()</a>
</p>
</li>
</ul></div>
</li>
<li>
<p>
<a href="#SERIALIZABLE_macros">"SERIALIZABLE" macros:</a>
</p>
<div class="ulist"><ul>
<li>
<p>
<a href="#ZAX_JSON_SERIALIZABLE">ZAX_JSON_SERIALIZABLE</a>
</p>
</li>
<li>
<p>
<a href="#ZAX_JSON_SERIALIZABLE_WDC">ZAX_JSON_SERIALIZABLE_WDC</a>
</p>
</li>
</ul></div>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="ZaxJsonFlatParser">ZaxJsonFlatParser</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Tokenizes the top element of a JSON string. The tokenized values are stored either in the <em>m_values</em> or the <em>m_list_values</em> member of the class, depending on whether the top element is a dictionary or a list.
Using ZaxJsonFlatParser class, a kind of a lazy parsing can be achieved.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><strong><em>It is recommended if there is no need to parse the whole JSON string.</em></strong></p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Constructor Syntax: <strong>ZaxJsonFlatParser([a_json], [a_in_situ], [a_success])</strong></p></div>
<div class="ulist"><div class="title"><em>Parameters</em></div><ul>
<li>
<p>
<em>a_json</em>: (input)(const char*) json string. Even it is passed as const, the string content might be changed during parsing.
</p>
</li>
<li>
<p>
<em>a_in_situ</em>: (input)(boolean) if <em>true</em>, the input string will be altered during parsing, resulting in a better performance. If you want to have your input string untouched, please set it to <em>false</em>. Default value is <em>true</em>.
</p>
</li>
<li>
<p>
<em>a_success</em>: (output)(boolean*) if used, the passed parameter will get a value of <em>true</em> if the parsing was successful, and a value of <em>false</em> otherwise. Default value is 0.
</p>
</li>
</ul></div>
<div class="ulist"><div class="title"><em>Returns</em></div><ul>
<li>
<p>
-
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">The library was not tested with invalid JSONS strings.</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">All the resulting tokens are <em>char*</em> strings, and may point in the original buffer, or a newly allocated one, depending on the value of the <em>a_in_situ</em> argument.</td>
</tr></table>
</div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>ZaxJsonFlatParser json_doc("{\"title\":\"some title\",\"x\":17}", false);

cout &lt;&lt; json_doc.m_values["title"] &lt;&lt; endl;
cout &lt;&lt; json_doc.m_values["x"] &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>some title
17</code></pre>
</div></div>
<div class="paragraph"><p><em>Example 2:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>ZaxJsonFlatParser json_doc("{\"title\":\"some title\",\"x\":17}", false);

const char* tmp = json_doc.m_values["no_such_key"];
cout &lt;&lt; (int) tmp &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>0</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">The return value should be checked for a <em>0</em> value. In case of lists, over indexing is not allowed.</td>
</tr></table>
</div>
<div class="paragraph"><p><em>Example 3:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>ZaxJsonFlatParser json_doc("[3, 7, 11]", false);

cout &lt;&lt; json_doc.m_list_values[0] &lt;&lt; endl;
cout &lt;&lt; json_doc.m_list_values[1] &lt;&lt; endl;
cout &lt;&lt; json_doc.m_list_values[2] &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>3
7
11</code></pre>
</div></div>
<div class="paragraph"><p><em>Example 4:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>ZaxJsonFlatParser json_doc("[\"3\", \"7\", \"11\"]", false);

cout &lt;&lt; json_doc.m_list_values[0] &lt;&lt; endl;
cout &lt;&lt; json_doc.m_list_values[1] &lt;&lt; endl;
cout &lt;&lt; json_doc.m_list_values[2] &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>3
7
11</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Mixed lists like <strong>[3, \"7\", \"11\"]</strong> are not supported.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Converter_functions">Converter functions</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>In order for these functions to work, a macro needs to be defined describing meta information on the <em>names</em> of the fields of the object to be converted to- or from json strings. Pls see the examples.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><strong><em>By using these functions, existing code does not need to be changed, therefore these might be used even for classes located in 3rd parties, or other places where no code change is desirable.</em></strong></p></div>
<div class="sect2">
<h3 id="zax_convert_to_json">zax_convert_to_json</h3>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Is a macro function which creates a json string from an object.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Syntax: <strong>zax_convert_to_json([a_json], [a_obj], [a_json_properties])</strong></p></div>
<div class="ulist"><div class="title"><em>Parameters</em></div><ul>
<li>
<p>
<em>a_json</em>: (output)(const char*) json string. Needs to be allocated by the caller.
</p>
</li>
<li>
<p>
<em>a_json_buffer_length</em>: (input)(int) the length of the memory field allocated for the json string passed as first argument.
</p>
</li>
<li>
<p>
<em>a_obj</em>: (input)(const some <em>class</em> with public members) The input object to be converted to a JSON string.
</p>
</li>
<li>
<p>
<em>a_json_properties</em>: (input)(descriptor macro) meta information on the members of the <em>class</em> of the object passed as <em>a_obj</em>.
</p>
</li>
</ul></div>
<div class="ulist"><div class="title"><em>Returns</em></div><ul>
<li>
<p>
boolean: <em>true</em> on success, <em>false</em> on fail.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Class members which are not present in the a_json_properties argument macro will not be inserted in the JSON string.</td>
</tr></table>
</div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>struct struct1
{
    int x = 7;
    string name = "seven";
};

#define struct1_json_properties JSON_PROPERTY(x), JSON_PROPERTY(name)

struct1 some_obj;

char json_string[1000];
zax_convert_to_json(json_string, sizeof(json_string), some_obj, struct1_json_properties);
cout &lt;&lt; json_string &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":7, "name":"seven"}</code></pre>
</div></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><strong>Aliases can be used by extending the json property descriptor in the following way:</strong></p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 2:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>...same code...

#define struct1_json_properties JSON_PROPERTY(x), JSON_PROPERTY(name, "with_letters")

...same code...</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":7, "with_letters":"seven"}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="zax_convert_from_json">zax_convert_from_json</h3>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Is a macro function which can fill up fields of an object with values from a json string.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Syntax: <strong>zax_convert_from_json([a_json], [a_obj], [a_json_properties])</strong></p></div>
<div class="ulist"><div class="title"><em>Parameters</em></div><ul>
<li>
<p>
<em>a_json</em>: (input)(const char*) json string. Even it is passed as const, the string content might be changed during parsing.
</p>
</li>
<li>
<p>
<em>a_obj</em>: (output)(some <em>class</em> with public members) The output object. The fields of this object will be filled with the values in the JSON string.
</p>
</li>
<li>
<p>
<em>a_json_properties</em>: (input)(descriptor macro) meta information on the members of the <em>class</em> of the object passed as <em>a_obj</em>.
</p>
</li>
</ul></div>
<div class="ulist"><div class="title"><em>Returns</em></div><ul>
<li>
<p>
boolean: <em>true</em> on success, <em>false</em> on fail.
</p>
</li>
</ul></div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>struct struct1
{
    int x = 7;
    string name = "seven";
};

#define struct1_json_properties JSON_PROPERTY(x), JSON_PROPERTY(name)

char json_string[] = "{\"x\":11, \"name\":\"eleven\"}";
zax_convert_from_json(json_string, some_obj, struct1_json_properties);

char json_string2[10000];
zax_convert_to_json(json_string2, sizeof(json_string2), some_obj, struct1_json_properties);
cout &lt;&lt; json_string2 &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":11, "name":"eleven"}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Possible extra elements in the input JSON string are ignored</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="SERIALIZABLE_macros">SERIALIZABLE macros:</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>These macros are adding some constructors and operators to your class, making your objects assignable with JSON strings, and printable to "cout".</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><strong><em>These macros are recommended if you are the one writing the code of the classes that needs to be JSON serializable, you need at least one of the features it provides, and the features does not interfere with other aspects of your design.</em></strong></p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="sect2">
<h3 id="ZAX_JSON_SERIALIZABLE">ZAX_JSON_SERIALIZABLE</h3>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Besides the constructors having <em>char*</em> and <em>string</em> arguments, this macro also adds a default constructor to your class.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define struct2_json_properties\
    JSON_PROPERTY(int1),\
    JSON_PROPERTY(int2),\
    JSON_PROPERTY(string1),\
    JSON_PROPERTY(string2)

struct struct2
{
    int int1;
    int int2;
    string string1;
    string string2;

    ZAX_JSON_SERIALIZABLE(struct2, struct2_json_properties)
};

string json_string = "{\"int1\":11, \"int2\":7, \"string1\":\"eleven\", \"string2\":\"seven\"}";
struct2 some_obj = json_string;
string json_string2 = some_obj;

cout &lt;&lt; json_string2 &lt;&lt; endl;
cout &lt;&lt; some_obj &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"int1":11, "int2":7, "string1":"eleven", "string2":"seven"}
{"int1":11, "int2":7, "string1":"eleven", "string2":"seven"}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">ZAX parsable classes needs to have a default constructor, and ZAX_JSON_SERIALIZABLE will try to add one to your code. Therefore, in case you already have your own default constructor, ZAX_JSON_SERIALIZABLE will not work. In this case please use the ZAX_JSON_SERIALIZABLE_WDC macro.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="ZAX_JSON_SERIALIZABLE_WDC">ZAX_JSON_SERIALIZABLE_WDC</h3>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>This macro adds only the constructors having <em>char*</em> and <em>string</em> arguments but adds no default constructor to your class.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define struct2_json_properties\
    JSON_PROPERTY(int1),\
    JSON_PROPERTY(int2),\
    JSON_PROPERTY(string1),\
    JSON_PROPERTY(string2)

struct struct2
{
    int int1;
    int int2;
    string string1;
    string string2;

    struct2()
        :int1(10)
    {}

    ZAX_JSON_SERIALIZABLE_WDC(struct2, struct2_json_properties)
};

string json_string = "{\"int1\":11, \"int2\":7, \"string1\":\"eleven\", \"string2\":\"seven\"}";
struct2 some_obj = json_string;
string json_string2 = some_obj;

cout &lt;&lt; json_string2 &lt;&lt; endl;
cout &lt;&lt; some_obj &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"int1":11, "int2":7, "string1":"eleven", "string2":"seven"}
{"int1":11, "int2":7, "string1":"eleven", "string2":"seven"}</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Parsing_of_data_structures">Parsing of data structures</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Currently <em>std::vectors</em> are supported:</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define struct3_json_props \
    JSON_PROPERTY(x), \
    JSON_PROPERTY(title, "name"), \
    JSON_PROPERTY(options)

struct struct3
{
    int x;
    string title;
    vector&lt;string&gt; options;

    ZAX_JSON_SERIALIZABLE(struct3, struct3_json_props)
};

struct3 obj1 = "{ \"x\":99, \"title\":\"test bible title\", \"options\":[\"option 1\", \"option 2\", \"option 3\"]}";
string json_string2 = obj1;

cout &lt;&lt; json_string2 &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":99, "name":"", "options":["option 1", "option 2", "option 3"]}</code></pre>
</div></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em><strong>It also works recursively:</strong></em></p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 2:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define struct3_json_props \
    JSON_PROPERTY(x), \
    JSON_PROPERTY(scores)

struct struct3
{
    int x = 9;
    std::vector&lt;std::vector&lt;int&gt;&gt; scores = {{1, 2, 3}, {7, 8, 9}};

    ZAX_JSON_SERIALIZABLE(struct3, struct3_json_props)
};

struct3 obj1;
cout &lt;&lt; obj1 &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":9, "scores":[[1, 2, 3], [7, 8, 9]]}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">The elements of the vectors in the JSON string might also be strings, even if the vector is of integers, and vice versa. No error or warning will be present, the parsing will be successful in both cases and in both directions. However, mixed lists are not supported.</td>
</tr></table>
</div>
<div class="paragraph"><p><em>Example 2:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define struct3_json_props \
    JSON_PROPERTY(x), \
    JSON_PROPERTY(options)

struct struct3
{
    int x = 9;
    vector&lt;int&gt; options;

    ZAX_JSON_SERIALIZABLE(struct3, struct3_json_props)
};

void json_example_03()
{
    struct3 obj1 = "{\"x\":99, \"options\":[\"1\", \"2\", \"3\"]}";
    string json_string2 = obj1;

    cout &lt;&lt; json_string2 &lt;&lt; endl;
}</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"x":99, "options":[1, 2, 3]}</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="Parsing_of_structures_with_fields_of_serializable_structures">Parsing of structures with fields of serializable structures</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p>Parsing of structures inside structures is also possible, if the meta info of the inner structures are also provided.</p></div>
<div class="paragraph"><p>&#160;<br /></p></div>
<div class="paragraph"><p><em>Example 1:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define CClassInside_JOSONProps\
    JSON_PROPERTY(x),\
    JSON_PROPERTY(y)

struct CClassInside
{
    int x = 11;
    int y = 7;

    ZAX_JSON_SERIALIZABLE(CClassInside, CClassInside_JOSONProps)
};

#define CClass_JOSONProps\
    JSON_PROPERTY(title),\
    JSON_PROPERTY(x),\
    JSON_PROPERTY(inside)

struct CClass
{
    CClassInside inside;
    int x = 6;
    string title = "some title";

    ZAX_JSON_SERIALIZABLE(CClass, CClass_JOSONProps)
};

CClass some_obj = "{\"title\": \"some other title\", \"x\": 17, \"inside\":{\"x\":9, \"y\":5}}";
cout &lt;&lt; some_obj &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>{"title":"some other title", "x":17, "inside":{"x":9, "y":5}}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Of course, you may combine all the features. Note that if you are using an alias name for a filed, you should use the alias name in the JSON string as well.</td>
</tr></table>
</div>
<div class="paragraph"><p><em>Example 2:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>#define CClassInside_JOSONProps\
    JSON_PROPERTY(x),\
    JSON_PROPERTY(y)

struct CClassInside
{
    int x = 11;
    int y = 7;

    ZAX_JSON_SERIALIZABLE(CClassInside, CClassInside_JOSONProps)
};

#define CClass_JOSONProps\
    JSON_PROPERTY(title),\
    JSON_PROPERTY(options),\
    JSON_PROPERTY(aspects, "criteria"),\
    JSON_PROPERTY(scores),\
    JSON_PROPERTY(x),\
    JSON_PROPERTY(inside),\
    JSON_PROPERTY(weights)

struct CClass
{
    CClassInside inside;
    int x = 6;
    string title = "some title";
    vector&lt;string&gt; options = {"option1", "option2", "option3"};
    vector&lt;string&gt; aspects = {"criteria1", "criteria2"};
    std::vector&lt;std::vector&lt;int&gt;&gt; scores = {{1, 2, 3}, {7, 8, 9}};
    vector&lt;int&gt; weights = {1, 2, 3};

    ZAX_JSON_SERIALIZABLE(CClass, CClass_JOSONProps)
};

char json_string_copy[10000];
strcpy(json_string_copy, "{\"x\":99, \"criteria\":[\"aspect x\"], \"title\":\"test title\", \"options\":[\"option 1\", \"option 2\", \"option 3\"], \"nonexisting_field\":\"\", \"scores\":[[1, 1, 2], [3, 5, 8], [13, 21], [34, 55]], \"weights\":[4, 3, 2, 1], \"inside\":{\"x\":\"11\", \"y\":\"9\"}}");

cout &lt;&lt; "Json string to be assigned to the object:" &lt;&lt; endl &lt;&lt; json_string_copy &lt;&lt; endl &lt;&lt; endl;

CClass some_obj = "{}";
cout &lt;&lt; "Field of the object before assignment: " &lt;&lt; endl &lt;&lt; some_obj &lt;&lt; endl &lt;&lt; endl;

some_obj = json_string_copy;
string json_std_string = some_obj;
cout &lt;&lt; "Json string computed after assignment: " &lt;&lt; endl &lt;&lt; json_std_string &lt;&lt; endl &lt;&lt; endl;</code></pre>
</div></div>
<div class="paragraph"><p><em>Result:</em></p></div>
<div class="listingblock">
<div class="content">
<pre><code>Json string to be assigned to the object:
{"x":99, "criteria":["aspect x"], "title":"test title", "options":["option 1", "option 2", "option 3"], "nonexisting_field":"", "scores":[[1, 1, 2], [3, 5, 8], [13, 21], [34, 55]], "weights":[4, 3, 2, 1], "inside":{"x":"11", "y":"9"}}

Values before assignment:
{"title":"some title", "options":["option1", "option2", "option3"], "criteria":["criteria1", "criteria2"], "scores":[[1, 2, 3], [7, 8, 9]], "x":6, "inside":{"x":11, "y":7}, "weights":[1, 2, 3]}

Json string computed after assignment:
{"title":"test title", "options":["option 1", "option 2", "option 3"], "criteria":["aspect x"], "scores":[[1, 1, 2], [3, 5, 8], [13, 21], [34, 55]], "x":99, "inside":{"x":11, "y":9}, "weights":[4, 3, 2, 1]}</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">As I was implementing the features I needed only, the implementations might be incomplete. Booleans for example are not suported at all. I have implemented the possibility of error handling, but I have skipped to implement the error handling itself in most of the cases, therefore while parsing invalid JSON strings the library might just cause your application to crash.</td>
</tr></table>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2020-12-14 10:12:13 Central Europe Standard Time
</div>
</div>
</body>
</html>
